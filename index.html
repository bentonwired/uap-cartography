<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Elessar</title>

    <!-- Favicon (64√ó64 circular PNG) -->
  <link
    rel="icon"
    href="favicon_circular.png"
    type="image/png"
    sizes="64x64"
  />

  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Load the Inter font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <link
  rel="stylesheet"
  href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.2/mapbox-gl-geocoder.css"
  type="text/css"
/>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.2/mapbox-gl-geocoder.min.js"></script>
  <style>
    :root {
    --banner-height: 35px;  /* Change this value to adjust banner height */
    --header-spacing: 50px; /* Space from top for UI elements */
    }
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;

      /* Set Inter as your global font */
      font-family: 'Inter', sans-serif;
      font-weight: 400;           /* normal text weight */
      line-height: 1.5;           /* a bit more breathing room */
    }
    /* make room for our fixed banner */
    body {
    position: relative;
    box-sizing: border-box;
    padding-top: var(--banner-height);
    }
    #map-container {
      position: absolute;
      top: var(--banner-height);
      bottom: 0;
      width: 100%;
      transition: opacity 0.4s ease, filter 0.5s ease-out;
      filter: none;
    }

    #map { position:absolute; top:0; bottom:0; width:100%; }
    .mapboxgl-popup {
      max-width: 300px;
      z-index: 1000 !important;
    }
    .legend {
      background: rgba(0,0,0,0.2);
      color: #fff;
      padding:10px;
      font-size:12px;
      font-family: 'Inter', sans-serif !important;
      position:absolute;
      bottom: 20px;
      right:10px;
      border-radius: 8px;
      z-index: 2 !important;    /* Ensure it's above map but below controls */
    }

    /* Mobile-specific legend positioning */
    @media (max-width: 768px) {
      .legend {
        bottom: 20px;
        top: auto !important;
        right: 10px;
        font-size: 10px;
        padding: 6px;
        max-width: 120px;
      }
    }

      /* permanently bottom-center the flight controls container */
      #flight-controls-container {
        z-index: 1003;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;

        /* you can fold these here instead of inline */
        background: rgba(255,255,255,0.9);
        padding: 8px;
        border-radius: 4px;
        font-family: sans-serif;
      }

      /* style the buttons inside the container */
      #flight-controls-container button {
        z-index: 10;
        padding: 6px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

    /* ‚îÄ‚îÄ Timeline Scrubber Styles ‚îÄ‚îÄ */
    #slider-container {
      display: none;
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      max-width: 400px;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 4px;
      z-index: 1;
    }
    #time-slider { width: 100%; }
    #time-label {
      text-align: center;
      color: #fff;
      margin-top: 4px;
      font-size: 12px;
    }
    /* Constrain popup dimensions and enable scrolling */
    .mapboxgl-popup-content {
      max-width: 345px;
      max-height: 500px;
      overflow-y: auto;
      overflow-wrap: break-word;
      white-space: normal;
    }
    /* Ensure all children wrap long words/URLs */
    .mapboxgl-popup-content * {
      word-break: break-word;
    }

    /* Top‚Äêbar sits over the map but is otherwise transparent */
    #top-bar {
      position: absolute;
      top: var(--banner-height);
      left: 0; right: 0;
      height: auto;
      pointer-events: all;
      z-index: 5;
    }

    /* hamburger on the left */
    #hamburger {
      position: absolute; top: calc(var(--banner-height) + -20px); left: 10px;
      pointer-events: all;
      background: rgba(0,0,0,0.4);
      border: none; color: #fff; font-size: 18px;
      padding: 6px; border-radius: 6px;
    }

    /* info button on the right */
    #info {
      position: absolute; top: calc(var(--banner-height) + -20px); right: 10px;
      pointer-events: all;
      background: rgba(0,0,0,0.6);
      border: none; color: #fff; font-size: 18px;
      padding: 6px; border-radius: 4px;
    }

    /* small centered search box */
    #search-box {
      position: absolute; top: calc(var(--banner-height) + -20px); left: 50%;
      transform: translateX(-50%);
      width: 220px;          /* adjust to taste */
      max-width: 60%;
      pointer-events: all;
      background: rgba(0,0,0,0.6);
      border: none; color: #fff; font-size: 14px;
      padding: 6px; border-radius: 4px;
    }

    /* container for our custom dropdown */
    .autocomplete-items {
      position: absolute;
      top: 35px;
      left: 50%;
      transform: translateX(-50%);
      width: 220px;
      max-height: 200px; /* Limit height on mobile */
      overflow-y: auto;
      background: rgba(0,0,0,0.6);
      border-radius: 4px;
      z-index: 6;
    }

    /* each suggestion */
    .autocomplete-items div {
      padding: 8px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
    }

    /* hover highlight */
    .autocomplete-items div:hover {
      background: rgba(255,255,255,0.2);
    }

    /* ensure the datalist dropdown inherits basic styles */
    datalist {
      color: #000;
    }

    /* Drawer hidden off‚Äêscreen by default */
    #drawer {
      position: absolute;
      top: var(--banner-height);
      bottom: 0;
      left: -280px;
      width: 280px;
      background: rgba(0,0,0,0.4);
      color: #fff;
      transition: left 0.3s ease;
      z-index: 4;
    }
    /* When open, slide in and hide the hamburger */
    #drawer.open {
      left: 0;
    }

    /* Drawer nav & content */
    #drawer nav {
      display: flex; background: rgba(255,255,255,0.04);
      flex-direction: column;    /* stack vertically */
    }
    #drawer nav button {
      flex: 1; padding: 10px; background: none;
      border: none; color: #fff; cursor: pointer;
      font-size: 14px;
      text-align: left;      /* optional, makes the labels align neatly */
      width: 100%;
    }
    #drawer-content {
      background: rgba(255,255,255,0.04);
      padding: 10px;
      overflow-y: auto !important;
      overflow-x: hidden !important;
      height: calc(100% - 40px); /* Account for nav height */
      position: relative;
      /* Enable smooth scrolling on mobile */
      -webkit-overflow-scrolling: touch;
      /* Firefox */
      scrollbar-width: none !important;
      /* IE/Edge */
      -ms-overflow-style: none !important;
    }

    /* Move the default zoom/rotation controls down below our header */
    .mapboxgl-ctrl-top-right {
      top: calc(var(--banner-height) + 10px) !important;
    }

    /* Main control group background */
    .mapboxgl-ctrl-group {
      background: rgba(0, 0, 0, 0.4) !important; /* Match your search box */
      border: none !important;
      box-shadow: 0 0 0 2px rgba(41, 182, 246, 0.1) !important; /* Subtle blue glow */
    }

    /* Individual buttons */
    .mapboxgl-ctrl-group button {
      background: transparent !important;
      border: none !important;
      color: #fff !important;
      transition: all 0.2s ease !important;
    }

    /* Button separators */
    .mapboxgl-ctrl-group button + button {
      border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
    }

    /* Hover state */
    .mapboxgl-ctrl-group button:hover {
      background-color: rgba(41, 182, 246, 0.2) !important; /* Blue tint on hover */
    }

    /* Active/focus state */
    .mapboxgl-ctrl-group button:active,
    .mapboxgl-ctrl-group button:focus {
      background-color: rgba(41, 182, 246, 0.3) !important;
      outline: none !important;
    }

    /* The actual icons (zoom in/out and compass) */
    .mapboxgl-ctrl-icon {
      filter: invert(1) !important; /* Makes white icons */
    }

    /* Compass specific styling */
    .mapboxgl-ctrl-compass .mapboxgl-ctrl-icon {
      background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23ffffff'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E") !important;
    }

    /* Disabled state */
    .mapboxgl-ctrl-group button:disabled {
      opacity: 0.5 !important;
    }

    /* Attribution control (if visible) */
    .mapboxgl-ctrl-attrib {
      background: rgba(0, 0, 0, 0.6) !important;
      color: rgba(255, 255, 255, 0.7) !important;
    }

    .mapboxgl-ctrl-attrib a {
      color: #29b6f6 !important; /* Your blue accent */
    }

    /* Recent list styling */
    #drawer-content ul.recent-list {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: calc(100% - 40px); /* leave room for header */
      overflow-y: auto;
    }
    #drawer-content li.recent-item {
      margin-bottom: 12px;
    }
    #drawer-content .recent-item .line {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #drawer-content .recent-item .line span:first-child {
      display: flex;
      align-items: center;
    }
    #drawer-content .recent-item .dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    #drawer-content .recent-item .snippet {
      margin-left: 14px;
      font-size: 11px;
      color: #ccc;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* NUCLEAR OPTION: Hide ALL scrollbars in drawer */

    /* 1. Hide scrollbars on drawer-content itself */
    #drawer-content {
      overflow-y: auto !important;
      overflow-x: hidden !important;

      /* Firefox */
      scrollbar-width: none !important;

      /* IE/Edge */
      -ms-overflow-style: none !important;
    }

    /* Webkit browsers (Chrome, Safari, newer Edge) */
    #drawer-content::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }

    /* 2. Hide scrollbars on ALL children of drawer-content */
    #drawer-content * {
      /* Firefox */
      scrollbar-width: none !important;

      /* IE/Edge */
      -ms-overflow-style: none !important;
    }

    #drawer-content *::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }

    /* 3. Specifically target any lists or containers */
    #drawer-content ul,
    #drawer-content .recent-list,
    #drawer-content .ticker-container,
    #drawer-content #filter-list {
      /* Firefox */
      scrollbar-width: none !important;

      /* IE/Edge */
      -ms-overflow-style: none !important;
    }

    #drawer-content ul::-webkit-scrollbar,
    #drawer-content .recent-list::-webkit-scrollbar,
    #drawer-content .ticker-container::-webkit-scrollbar,
    #drawer-content #filter-list::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }

    /* 4. Target the drawer itself in case it's showing scrollbars */
    #drawer {
      overflow: hidden !important;
    }

    /* 5. Mobile-specific hiding (sometimes mobile browsers ignore the above) */
    @media (max-width: 768px) {
      #drawer-content {
        /* Use transform hack for iOS */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);

        /* Ensure touch scrolling works but hide bars */
        -webkit-overflow-scrolling: touch;
        overflow-y: scroll !important;
      }

      /* Double-ensure no scrollbars on mobile */
      #drawer-content::-webkit-scrollbar,
      #drawer-content *::-webkit-scrollbar {
        display: none !important;
        -webkit-appearance: none !important;
        width: 0 !important;
        height: 0 !important;
      }
    }

    #drawer nav button {
    font-family: 'Inter', sans-serif !important;
  }

    /* hide the hamburger once the drawer is open */
    .drawer-open #hamburger {
      display: none;
    }

    /* ‚îÄ‚îÄ Blur the map while loading ‚îÄ‚îÄ */
#map-container.loading {
  transition: none;
  filter: blur(8px);
}

    /* ‚îÄ‚îÄ Full-screen overlay ‚îÄ‚îÄ */
    #loading-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    /* ‚îÄ‚îÄ 3) absolute center both lines ‚îÄ‚îÄ */
    .loading-text {
      position: relative;
      width: 100%;
      height: 1.5rem;           /* match or exceed your font-size/line-height */
    }
    .loading-text .line {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Cinzel', serif;
      font-size: 1.25rem;
      color: #fff;
      opacity: 0;
    }

    /* ‚îÄ‚îÄ 4) fade-in/out keyframes ‚îÄ‚îÄ */
    @keyframes fadeInOut {
      /* first 10% = fade in, next 80% = stay visible, last 10% = fade out */
      0%   { opacity: 0; transform: translate(-50%, -50%) translateY(10px); }
      10%  { opacity: 1; transform: translate(-50%, -50%) translateY(0); }
      90%  { opacity: 1; transform: translate(-50%, -50%) translateY(0); }
      100% { opacity: 0; transform: translate(-50%, -50%) translateY(0); }
    }

    /* ‚îÄ‚îÄ 5) line-specific timing ‚îÄ‚îÄ */
    /* Line 1: 2s animation, starts at 0.3s */
    .loading-text .line1 {
      animation: fadeInOut 2s forwards;
      animation-delay: 0.3s;
    }
    /* Line 2: 2s animation, starts at 2.5s */
    .loading-text .line2 {
      animation: fadeInOut 2s forwards;
      animation-delay: 2.5s;
    }

    /* ‚îÄ‚îÄ 6) overlay fade‚Äêout ‚îÄ‚îÄ */
    #loading-screen.fade-out {
      animation: fadeOut 0.2s forwards;
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to   { opacity: 0; }
    }

    /* hide by default */
    #about-modal.hidden { display: none; }

    /* backdrop and center panel */
    #about-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 1000;
    }
    #about-modal .modal-backdrop {
      position: absolute;
      top:0; left:0; right:0; bottom:0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
    }
    #about-modal .modal-content {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      max-width: 600px;
      width: 90%;
      max-height: calc(90% - var(--banner-height));
      margin-top: calc(var(--banner-height) / 2);
      overflow-y: auto;
      background: #111;
      color: #eee;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 0 12px rgba(0,0,0,0.8);
      font-family: 'Inter', sans-serif;
    }

    /* Brand-centered logo atop the About panel */
    #about-modal .modal-logo {
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }
    #about-modal .modal-logo img {
      border-radius: 50%;                  /* keep it perfectly circular */
      border: 2px solid rgba(255,255,255,0.2);
      box-shadow: 0 0 12px rgba(41,182,246,0.6); /* gentle sky-blue glow */
    }

    /* close button */
    #about-close {
      position: absolute;
      top: 12px; right: 12px;
      background: none;
      border: none;
      color: #ccc;
      font-size: 1.25rem;
      cursor: pointer;
    }

    #about-modal .tagline {
      font-style: italic;        /* keep the italics */
      font-size: 0.75rem;        /* smaller than normal text */
      color: rgba(255, 255, 255, 0.6);  /* lighter, more subtle */
      margin-top: 8px;           /* a bit tighter to the header */
      text-align: left;        /* left under the title */
    }

    /* hint styling */
    #about-modal .hint {
      font-style: italic;
      margin-bottom: 0.75em;
      color: #ccc;
    }

    /* headings within modal */
    #about-modal .modal-content h3 {
      margin-top: 1.25em;
      margin-bottom: 0.5em;
      font-size: 1rem;
      color: #fff;
    }

    /* FAQ items */
    #about-modal .faq-item {
      margin-bottom: 0.75em;
    }
    #about-modal .faq-item p {
      margin: 0.25em 0 0 0;
      font-size: 0.9rem;
      color: #ddd;
    }
    #about-modal ul {
      padding-left: 1.2em;
      color: #ddd;
    }
    #about-modal ul li {
      margin-bottom: 0.5em;
    }

    /* Style the summary arrow and hover effect */
    details summary {
      cursor: pointer;
      padding: 6px 0;
      font-size: 1rem;
    }
    details[open] summary {
      /* optional bold when open */
      font-weight: 600;
    }

    /* Indent the contents */
    details .faq-item,
    details ul {
      margin-left: 1em;
      margin-top: 0.5em;
    }

    /* ‚îÄ‚îÄ Quick Links ‚îÄ‚îÄ */
    #about-modal .modal-content ul.quick-links {
      list-style: none;
      padding: 0;
      margin: 0 0 1em 0;
    }
    #about-modal .modal-content ul.quick-links li {
      margin-bottom: 0.5em;
    }
    /* anchor styling */
    #about-modal .modal-content ul.quick-links li a {
      color: #29b6f6;           /* soft sky blue */
      text-decoration: none;
      font-weight: 500;
    }
    #about-modal .modal-content ul.quick-links li a:hover {
      text-decoration: underline;
    }

    /* ‚îÄ‚îÄ Blue-themed Buy Me a Coffee button ‚îÄ‚îÄ */
    .bmc-button {
      display: inline-flex;
      align-items: center;
      background: rgba(41, 182, 246, 0.3);      /* soft sky-blue at 30% opacity */
      color: #fff;                              /* white text for contrast */
      border: 1px solid rgba(41, 182, 246, 0.6);/* slightly stronger blue border */
      padding: 6px 12px;
      border-radius: 4px;
      font-weight: 600;
      text-decoration: none;
      transition: background 0.2s ease, border-color 0.2s ease;
      margin-top: 0.25em;
    }

    .bmc-button:hover {
      background: rgba(41, 182, 246, 0.5);      /* deepen on hover */
      border-color: rgba(41, 182, 246, 0.8);
    }

    .bmc-button .coffee-icon {
      margin-right: 6px;
      /* keep the icon white */
    }

    .sidebar-brand {
      display: flex;
      align-items: center;
      padding: 0.75rem 0rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 1rem;
    }
    .sidebar-brand img {
      margin-right: 0.5rem;
    }
    .sidebar-brand span {
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
    }

    .drawer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .close-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.4rem;
      cursor: pointer;
    }


    @media (max-width: 768px) {
      :root {
        --banner-height: 40px;
      }

      /* Reduce button sizes on mobile */
      #hamburger, #info {
        padding: 12px;
        font-size: 16px;S
      }

      /* Better search box on mobile */
      #search-box {
        width: 140px;
        font-size: 12px;
        padding: 4px;
        top: calc(var(--banner-height) + -30px); /* Slightly closer to banner */
      }

      /* Adjust button positions on mobile */
      #hamburger {
        top: calc(var(--banner-height) + -30px);
        left: 8px;
      }

      #info {
        top: calc(var(--banner-height) + -30px);
        right: 8px;
      }

      /* Drawer adjustments */
      #drawer {
        width: 240px;
      }

      /* Hide legend text on very small screens, show only colors */
      @media (max-width: 380px) {
        .legend h4 {
          font-size: 10px;
          margin: 0 0 4px 0;
        }
      }
    }

    /* Hide search box when drawer is open on mobile */
    @media (max-width: 768px) {
      .drawer-open #search-box,
      .drawer-open #autocomplete-list {
        display: none !important;
      }
    }

    /* Video player styling in popups */
    .mapboxgl-popup-content video {
        width: 100%;
        max-width: 320px;
        height: auto;
        border-radius: 4px;
        background: #000;
        margin: 8px 0;
    }

    /* Video container with loading state */
    .video-container {
        position: relative;
        width: 100%;
        max-width: 320px;
        margin: 10px 0;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        min-height: 180px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Loading spinner for videos */
    .video-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #29b6f6;
        font-size: 12px;
    }

    /* Error state for failed videos */
    .video-error {
        padding: 20px;
        text-align: center;
        color: #999;
        font-size: 12px;
    }

    /* Fallback link styling */
    .video-fallback {
        display: block;
        padding: 8px;
        background: rgba(41, 182, 246, 0.2);
        border: 1px solid rgba(41, 182, 246, 0.4);
        border-radius: 4px;
        text-align: center;
        color: #29b6f6;
        text-decoration: none;
        margin-top: 8px;
    }

    .video-fallback:hover {
        background: rgba(41, 182, 246, 0.3);
        border-color: rgba(41, 182, 246, 0.6);
    }

    /* Customize popup background and transparency */
    .mapboxgl-popup-content {
      background: rgba(0, 0, 0, 0.65) !important;  /* Dark background with 85% opacity */
      color: #fff !important;                      /* White text */
      border-radius: 8px !important;
      box-shadow: 0 2px 10px rgba(41, 182, 246, 0.3) !important;  /* Blue glow to match theme */
    }

    /* Style the popup tip/arrow */
    .mapboxgl-popup-tip {
      border-top-color: rgba(0, 0, 0, 0.85) !important;
    }

    /* Style links within popups */
    .mapboxgl-popup-content a {
      color: #29b6f6 !important;  /* Your blue accent color */
      text-decoration: underline;
    }

    .mapboxgl-popup-content a:hover {
      color: #4fc3f7 !important;  /* Lighter blue on hover */
    }

    /* Style the close button */
    .mapboxgl-popup-close-button {
      color: #fff !important;
      font-size: 18px !important;
    }

    .mapboxgl-popup-close-button:hover {
      background-color: rgba(255, 255, 255, 0.1) !important;
    }

    /* Style the details/summary elements in popups */
    .mapboxgl-popup-content details summary {
      color: #29b6f6 !important;
    }

    /* Style the table within popups */
    .mapboxgl-popup-content table {
      color: #ddd !important;
    }

    .mapboxgl-popup-content th {
      color: #29b6f6 !important;  /* Blue headers */
    }

    /* Webkit browsers (Chrome, Safari, Edge) */
    .mapboxgl-popup-content::-webkit-scrollbar {
      width: 8px;
    }

    .mapboxgl-popup-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    .mapboxgl-popup-content::-webkit-scrollbar-thumb {
      background: rgba(41, 182, 246, 0.5);  /* Your blue theme color */
      border-radius: 4px;
    }

    .mapboxgl-popup-content::-webkit-scrollbar-thumb:hover {
      background: rgba(41, 182, 246, 0.8);  /* Brighter on hover */
    }

    /* Firefox */
    .mapboxgl-popup-content {
      scrollbar-width: thin;
      scrollbar-color: rgba(41, 182, 246, 0.5) rgba(255, 255, 255, 0.1);
    }

    /* Fixed video formatting in popups */
    .mapboxgl-popup-content {
        max-width: 380px !important;
        max-height: 80vh !important; /* Prevents popup from being too tall */
        overflow-y: auto !important;
    }

    /* Ensure video container maintains aspect ratio */
    .mapboxgl-popup-content video {
        max-width: 100%;
        height: auto;
    }

    /* Spiderify styles */
    .spider-leg {
      stroke: rgba(41, 182, 246, 0.8);
      stroke-width: 2;
      stroke-dasharray: 3, 3;
      animation: spider-dash 20s linear infinite;
      transition: none !important;
      will-change: transform, width, left, top;
      pointer-events: none !important;
      z-index: 997 !important;
    }

    @keyframes spider-dash {
      to {
        stroke-dashoffset: -60;
      }
    }

    .spiderfy-marker {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 50 !important;
      transform: translate(-50%, -50%);
      transform-origin: center;
    }

    .spiderfy-marker:hover {
      transform: scale(1.3);
      z-index: 60 !important;
    }
  </style>
</head>
<body>
<!-- LOADING SCREEN -->
  <div id="loading-screen">
    <div class="loading-text">
      <div class="line line1">For the hope that was hidden,</div>
      <div class="line line2">For the light that returns.</div>
    </div>
  </div>

<!-- Flight controls (initially hidden) -->
<div id="flight-controls-container" style="display:none;">
  <button id="load-data-btn">Reload Flights</button>
  <button id="play-pause-btn" disabled>Play</button>
  <button id="close-btn" disabled>Close</button>
</div>

<div
  id="event-date-banner"
  style="
    position: fixed;
    top: 0; left: 0; right: 0;
    height: var(--banner-height);
    background-color: rgba(33, 37, 41, 0.9);
    color: #b3e5fc;
    text-align: center;
    padding: 0 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 14px;
    border-bottom: 0.1px solid #29b6f6;
    z-index: 1001;
    box-sizing: border-box;
    white-space: normal;
    line-height: 1.2;
  "
>
  ‚ö†Ô∏è Alpha Notice: date/location quirks may occur and mobile support is limited. ‚ö†Ô∏è
</div>

<!-- ABOUT MODAL -->
<div id="about-modal" class="hidden">
  <div class="modal-backdrop"></div>
  <div class="modal-content">
    <button id="about-close">‚úï</button>

    <!-- ‚òÖ New logo header -->
    <div class="modal-logo">
      <img
        src="logo_detailed.png"
        alt="Elessar logo"
        width="80" height="80"
      />
    </div>

    <h2>About Elessar</h2>
<p class="tagline">‚ÄúNo, but I served in a company of heroes.‚Äù</p>
    <!-- 1) What & Why -->
    <p>
      Elessar is a <strong>fully automated & AI Integrated UAP pipeline</strong> created in response to the lack of high quality and near-real-time UAP sightings: it scrapes public sources on (Reddit, X, Instagram) and ingests only time-stamped and geolocated <strong>video</strong> evidence‚Äîno static images, no text-only reports.
      Every sighting is tagged with geolocation, a UTC timestamp, and a direct video link - all of which are vetted against OpenAI's 4.1mini GPT model.
    </p>

    <!-- 2) Quick Links + Buy Me a Coffee -->
    <h3>Quick Links</h3>
    <ul class="quick-links">
      <li><a href="https://github.com/bentonwired/uap-cartography" target="_blank">Source on GitHub</a></li>
      <li><a href="https://x.com/bentonwired" target="_blank">Follow me on X</a></li>
      <li><a href="mailto:bentonwired@gmail.com">Contact</a></li>
      <li>
        <!-- Buy Me a Coffee button -->
        <a href="https://www.buymeacoffee.com/bentonwired"
           target="_blank"
           class="bmc-button">
          <span class="coffee-icon">‚òï</span>
          Buy me a coffee
        </a>
      </li>
    </ul>


    <!-- 3) Version -->
    <h3>Version</h3>
    <p>0.2.5 (alpha)</p>

    <!-- 4) FAQ (collapsed by default) -->
    <details>
      <summary><strong>FAQ</strong></summary>

      <div class="faq-item">
        <strong>Q: Why did you build Elessar?</strong>
        <p>A: I‚Äôm a backend dev in a cartographic field and couldn't really find anyone automating a video-only, high-quality UAP database/map.</p>
      </div>

      <div class="faq-item">
        <strong>Q: Is Elessar open source?</strong>
        <p>Absolutely. The full code lives under the MIT license on GitHub‚Äîfeel free to fork, run your own instance, or even contribute back</p>
      </div>

      <div class="faq-item">
        <strong>Q: How fresh is the data?</strong>
        <p>A: Right now I re-scrape and re-score every six hours. My goal is sub-hourly or even real-time once I optimize rate limits and parallelize the pipeline.</p>
      </div>

      <div class="faq-item">
        <strong>Q: What is the confidence score?</strong>
        <p>A: I score each video 0‚Äì10 based on clarity, metadata integrity, and source reliability‚Äîhigher means more trustworthy.</p>
      </div>

      <div class="faq-item">
        <strong>Q: Is it mobile-friendly?</strong>
        <p>A: This alpha is optimized for desktop; a responsive mobile UI is coming in a future release as the user experience is refined.</p>
      </div>

      <div class="faq-item">
        <strong>Q: What counts as a ‚Äúverified‚Äù sighting?</strong>
        <p>A: Only time-stamped videos with extractable GPS/location data make the cut‚Äîno still images or text-only reports.</p>
      </div>

      <div class="faq-item">
        <strong>Q: What data sources do you use?</strong>
        <p>A: I started with r/UFOs on Reddit because it‚Äôs super structured (timestamps and location tags on every post). I‚Äôm almost done integrating X, and Instagram and YouTube are next on deck.</p>
      </div>

      <div class="faq-item">
        <strong>Q: How do I submit my own sighting?</strong>
        <p>A: Coming soon: a ‚ÄúSubmit‚Äù portal where you‚Äôll upload or link your video and pin the location.</p>
      </div>

      <div class="faq-item">
        <strong>Q: Where can I find more established UAP data?</strong>
        <p>A: For decades of thorough work, check out MUFON and NUFORC. They accept a wider range of reports, expert reviews, and interviews‚Äîconsider supporting them to keep their investigations ongoing.</p>
      </div>

      <div class="faq-item">
        <strong>Q: Why video only? Doesn‚Äôt that exclude eyewitness reports?</strong>
        <p>A: Video guarantees verifiable time and place‚Äîtext reports can‚Äôt be automated at scale. You can still share context elsewhere, but on Elessar video is king.</p>
      </div>

      <div class="faq-item">
        <strong>Q: How do you handle broken links, removed videos, or content takedowns?</strong>
        <p>A: I‚Äôm building a caching/embedding fallback so that when I first ingest a video, it‚Äôs stored on our CDN for a limited time. My pipeline will (future*) also re-check each link daily and flag any dead ones for review or replacement.</p>
      </div>

    </details>

    <!-- 5) Known Issues (also collapsible) -->
    <details>
      <summary><strong>Known Issues</strong></summary>
      <ul>
        <li><strong>Popup duplication at edges:</strong> When a point is near the top or bottom of the map, the popup can render twice (one clipped at the edge and one ‚Äúleaking‚Äù on the opposite side).</li>
        <li><strong>Popup content overlap:</strong> Long field names or values sometimes overlap table columns in the details view.</li>
        <li><strong>Explorer region label stickiness:</strong> If you fly manually after picking a region, the region name stays stuck in the search bar until you clear or re-select it.</li>
        <li><strong>Timeline toggle glitch:</strong> Clicking the ‚ÄúTimeline‚Äù tab when it‚Äôs already on will uncheck the box but leave the slider visible.</li>
        <li><strong>Stats chart is unlabeled:</strong> The 7-day sparkline doesn‚Äôt yet show Mon‚ÄìSun or date labels along the axis.</li>
        <li><strong>Autocomplete overflow:</strong> On narrow screens the dropdown of suggestions can spill off the bottom or sides of the viewport.</li>
      </ul>
    </details>

  </div>
</div>

  <!-- Invisible header icons -->
  <div id="top-bar">
    <button id="hamburger">‚ò∞</button>
  <input
    id="search-box"
    type="text"
    placeholder="Explore a region‚Ä¶"
    autocomplete="off"
  />
  <!-- autocomplete dropdown will live here -->
  <div id="autocomplete-list" class="autocomplete-items"></div>

    <button id="info">‚ÑπÔ∏è</button>
  </div>

<!-- Sliding drawer -->
<aside id="drawer" class="closed">

  <!-- ‚ë† Drawer header: brand + close button -->
  <div class="drawer-header">
    <div class="sidebar-brand">
      <img src="logo_detailed.png" alt="Elessar logo" width="32" height="32" />
      <span>Elessar</span>
    </div>
    <button id="close-drawer" class="close-btn" aria-label="Close menu">&times;</button>
  </div>

  <nav>
      <button data-panel="recent">Recent</button>
      <button data-panel="filter">Filter</button>
      <button data-panel="timeline">Timeline</button>
      <button data-panel="stats">Stats</button>
      <button data-panel="confidence">Confidence</button>
    </nav>
    <div id="drawer-content"></div>
  </aside>
  <div id="map-container"><div id="map"></div></div>
  <div class="legend" id="legend"></div>

  <!-- ‚îÄ‚îÄ Timeline Scrubber ‚îÄ‚îÄ -->
  <div id="slider-container">
    <input type="range" id="time-slider" />
    <div id="time-label"></div>
  </div>

<script>
  // Preload flight data so we know if there‚Äôs anything to show
  window.flightDataCache = [];
  fetch('batch_flight_pings.geojson')            // ‚Üê use your real test filename
    .then(res => res.json())
    .then(json => { window.flightDataCache = json.features; })
    .catch(err => {
      console.error('Could not load test flights:', err);
      window.flightDataCache = [];
    });
</script>

<script>
// Custom Spiderifier Implementation
// Custom Spiderifier Implementation
class MapboxglSpiderifier {
  constructor(map, options = {}) {
    this.map = map;
    this.options = {
      animate: options.animate !== false,
      animationSpeed: options.animationSpeed || 200,
      circleFootSeparation: options.circleFootSeparation || 25,
      circleSpiralSwitchover: options.circleSpiralSwitchover || 10,
      legWeight: options.legWeight || 2,
      legColor: options.legColor || 'rgba(41, 182, 246, 0.5)',
      markerWidth: options.markerWidth || 12,
      markerHeight: options.markerHeight || 12,
      markerBorder: options.markerBorder || 2,
      ...options
    };
    this.spiderfied = new Map();
    this.originalPositions = new Map();
  }

  spiderfy(center, markers) {
    console.log(`üï∑Ô∏è Spiderfying ${markers.length} markers at`, center);

    // Clear any existing spiderfied markers
    this.unspiderfy();

    const count = markers.length;
    const centerPt = this.map.project(center);
    const positions = this._generatePositions(count);

    const spiderfiedData = {
      center: center,
      markers: [],
      legs: [],
      debugDots: [] // Initialize here
    };

    markers.forEach((marker, i) => {
      // Store original position (which should be the cluster center)
      this.originalPositions.set(marker, center);

      // Calculate new position
      const angle = positions[i].angle;
      const distance = positions[i].distance;

      const newX = centerPt.x + Math.cos(angle) * distance;
      const newY = centerPt.y + Math.sin(angle) * distance;
      const newLngLat = this.map.unproject([newX, newY]);

      // Create leg element
      const leg = this._createLeg(center, newLngLat);
      this.map.getCanvasContainer().appendChild(leg);

      // Set marker initial position to center before animating
      marker.setLngLat(center);
      marker.addTo(this.map);

      // Animate or directly position marker
      if (this.options.animate) {
        // Small delay to ensure marker is added to map first
        setTimeout(() => {
          this._animateMarker(marker, center, newLngLat, this.options.animationSpeed);
        }, 50);
      } else {
        marker.setLngLat(newLngLat);
        // Update legs immediately if not animating
        setTimeout(() => {
          this._updateLegs();
        }, 10);
      }

      spiderfiedData.markers.push(marker);
      spiderfiedData.legs.push(leg);
    });

    // Debug: Add red dots AFTER the forEach loop
    const debugDots = [];
    markers.forEach((marker, i) => {
      const debugEl = document.createElement('div');
      debugEl.className = 'spider-debug-dot';
      debugEl.style.cssText = `
        position: absolute;
        width: 4px;
        height: 4px;
        background: red;
        border: 1px solid white;
        border-radius: 50%;
        z-index: 1002;
        pointer-events: none;
      `;
      this.map.getCanvasContainer().appendChild(debugEl);
      debugDots.push(debugEl);
    });

    // Store debug dots with spiderfied data
    spiderfiedData.debugDots = debugDots;

    // Update debug dot positions on map move
    const updateDebugDots = () => {
      markers.forEach((marker, i) => {
        const pos = this.map.project(marker.getLngLat());
        debugDots[i].style.left = `${pos.x - 2}px`; // For 4px dot
        debugDots[i].style.top = `${pos.y - 2}px`;
      });
    };
    updateDebugDots();

    // Add to the move listener
    this._updateDebugDotsOnMove = updateDebugDots;
    this.map.on('move', this._updateDebugDotsOnMove);

    this.spiderfied.set(center.toString(), spiderfiedData);

    // Update legs on map move
    this._updateLegsOnMove = () => this._updateLegs();
    this.map.on('move', this._updateLegsOnMove);

    return spiderfiedData.markers;
  }

  _updateLegs() {
    this.spiderfied.forEach((data, key) => {
      data.legs.forEach((leg, i) => {
        const marker = data.markers[i];
        const markerLngLat = marker.getLngLat();
        const centerPt = this.map.project(data.center);
        const markerPt = this.map.project(markerLngLat);

        const dx = markerPt.x - centerPt.x;
        const dy = markerPt.y - centerPt.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        leg.style.width = `${length}px`;
        leg.style.left = `${centerPt.x}px`;
        leg.style.top = `${centerPt.y - this.options.legWeight / 2}px`;
        leg.style.transform = `rotate(${angle}deg)`;
        leg.style.transformOrigin = '0 50%';
      });
    });
  }

  unspiderfy() {
    // Remove the move listeners
    if (this._updateLegsOnMove) {
      this.map.off('move', this._updateLegsOnMove);
    }
    if (this._updateDebugDotsOnMove) {
      this.map.off('move', this._updateDebugDotsOnMove);
    }

    this.spiderfied.forEach(data => {
      // Remove legs with fade out
      data.legs.forEach(leg => {
        if (leg.parentNode) {
          leg.style.opacity = '0';
          leg.style.transition = 'opacity 200ms';
          setTimeout(() => {
            if (leg.parentNode) {
              leg.parentNode.removeChild(leg);
            }
          }, 200);
        }
      });

      // Remove debug dots
      data.debugDots?.forEach(dot => {
        if (dot.parentNode) {
          dot.parentNode.removeChild(dot);
        }
      });

      // Remove markers
      data.markers.forEach(marker => {
        marker.remove();
      });
    });

    this.spiderfied.clear();
    this.originalPositions.clear();
  }

  _generatePositions(count) {
    const positions = [];
    const separation = this.options.circleFootSeparation;
    const dynamicSeparation = Math.max(separation, separation * Math.sqrt(count / 5));

    if (count >= this.options.circleSpiralSwitchover) {
      // Spiral layout for many markers
      let angle = 0;
      let legLength = dynamicSeparation * 2;
      const angleStep = (Math.PI * 2) / Math.min(7, count);

      for (let i = 0; i < count; i++) {
        positions.push({
          angle: angle,
          distance: legLength
        });
        angle += angleStep;
        // Gradually increase distance for spiral effect
        legLength += dynamicSeparation * 0.15;
      }
    } else {
      // Circle layout for few markers - evenly distributed
      const angleStep = (Math.PI * 2) / count;
      const distance = dynamicSeparation * Math.max(2.5, count * 0.5);

      for (let i = 0; i < count; i++) {
        // Start from top (12 o'clock) and go clockwise
        const angle = (i * angleStep) - (Math.PI / 2);
        positions.push({ angle, distance });
      }
    }

    return positions;
  }

  _createLeg(from, to) {
    const fromPt = this.map.project(from);
    const toPt = this.map.project(to);

    const dx = toPt.x - fromPt.x;
    const dy = toPt.y - fromPt.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

    const leg = document.createElement('div');
    leg.className = 'spider-leg';

    // Use a more robust positioning approach
    leg.style.cssText = `
      position: absolute;
      height: ${this.options.legWeight}px;
      background: linear-gradient(to right,
        transparent 0%,
        ${this.options.legColor} 10%,
        ${this.options.legColor} 90%,
        transparent 100%
      );
      width: ${length}px;
      left: ${fromPt.x}px;
      top: ${fromPt.y - this.options.legWeight / 2}px;
      transform-origin: 0 50%;
      transform: rotate(${angle}deg);
      pointer-events: none;
      z-index: 10;
      opacity: 0;
      transition: opacity 200ms;
    `;

    // Fade in the leg
    setTimeout(() => {
      leg.style.opacity = '1';
    }, 10);

    return leg;
  }

  _animateMarker(marker, from, to, duration) {
    const start = performance.now();
    const fromPt = this.map.project(from);
    const toPt = this.map.project(to);

    const animate = (now) => {
      const elapsed = now - start;
      const progress = Math.min(elapsed / duration, 1);

      // Ease out cubic
      const eased = 1 - Math.pow(1 - progress, 3);

      // Interpolate pixel coordinates
      const currentX = fromPt.x + (toPt.x - fromPt.x) * eased;
      const currentY = fromPt.y + (toPt.y - fromPt.y) * eased;

      // Convert back to lng/lat and update marker
      const currentLngLat = this.map.unproject([currentX, currentY]);
      marker.setLngLat(currentLngLat);

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        // Force exact final position
        marker.setLngLat(to);
        // IMPORTANT: Update legs AFTER animation completes
        setTimeout(() => {
          this._updateLegs();
        }, 10);
      }
    };

    requestAnimationFrame(animate);
  }
}

// Make it globally available
window.MapboxglSpiderifier = MapboxglSpiderifier;
console.log('‚úÖ Custom MapboxglSpiderifier loaded');
</script>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiYmVudG9ud2lyZWQiLCJhIjoiY21hMGNtNHAzMTNvcjJqb3I1ajhlZ2FlcyJ9.A-o67AZybXMb4JPmWj4HGQ';
    // Global spiderifier instance
    let spiderifier = null;

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/dark-v10',
      center: [-98,38],
      zoom: 3
    });

    // grab the elements
    const loadingScreen = document.getElementById('loading-screen');
    const mapContainer  = document.getElementById('map-container');
    const line2 = document.querySelector('.loading-text .line2');

    // 1) immediately blur the map
    mapContainer.classList.add('loading');

    // 2) Add listener to fade blur out
    line2.addEventListener('animationend', () => {
    // this fires exactly when your "For the light that returns." animation finishes
    loadingScreen.classList.add('fade-out');
    });

    // 3) after fade-out finishes, clean up
    loadingScreen.addEventListener('animationend', (e) => {
      if (e.animationName === 'fadeOut') {
        loadingScreen.remove();                   // drop the overlay
        mapContainer.classList.remove('loading'); // un-blur the map

        // ‚îÄ‚îÄ OPEN the drawer & select Recent ‚îÄ‚îÄ
      const drawer      = document.getElementById('drawer');
      const recentBtn   = document.querySelector('#drawer nav button[data-panel="recent"]');
      drawer.classList.add('open');
      document.body.classList.add('drawer-open');
      if (recentBtn) recentBtn.click();
      }
    });

    // ‚îÄ‚îÄ REGION CONFIG ‚îÄ‚îÄ
    const regions = {
      'United States':  { center: [-98.5795, 39.8283], zoom: 3    },
      'North America':  { center: [-100, 45],        zoom: 2    },
      'South America':  { center: [-60,  -15],       zoom: 2    },
      'Europe':         { center: [10,   50],        zoom: 3    },
      'Africa':         { center: [20,    0],        zoom: 2    },
      'Asia':           { center: [100,   34],       zoom: 2    },
      'Oceania':        { center: [140,  -25],       zoom: 3    },
      'Antarctica':     { center: [0,    -75],       zoom: 1.5  }
    };

    // ‚îÄ‚îÄ CUSTOM AUTOCOMPLETE LOGIC ‚îÄ‚îÄ
    const searchInput      = document.getElementById('search-box');
    const autocompleteList = document.getElementById('autocomplete-list');
    const regionKeys       = Object.keys(regions);

    function closeAllLists() {
      autocompleteList.innerHTML = '';
    }

    function buildList(arr) {
      closeAllLists();
      arr.forEach(label => {
        const item = document.createElement('div');
        item.textContent = label;
        item.addEventListener('click', () => {
          // 1) set the input
          searchInput.value = label;
          // 2) fly map
          const cfg = regions[label];
          map.flyTo({ center: cfg.center, zoom: cfg.zoom, speed: 0.8 });
          // 3) close dropdown
          closeAllLists();
        });
        autocompleteList.appendChild(item);
      });
    }

    // show all when focused
    searchInput.addEventListener('focus', () => {
      buildList(regionKeys);
    });

    // filter as you type
    searchInput.addEventListener('input', e => {
      const val = e.target.value.trim().toLowerCase();
      const matches = val === ''
        ? regionKeys
        : regionKeys.filter(k => k.toLowerCase().startsWith(val));
      buildList(matches);
    });

    // Replace your entire document click listener with this:
    document.addEventListener('mousedown', e => {
      // Use mousedown instead of click for better cross-browser consistency
      if (!searchInput.contains(e.target) && !autocompleteList.contains(e.target)) {
        closeAllLists();
      }
    });

    // Also, modify your item click handlers to use mousedown:
    function buildList(arr) {
      closeAllLists();
      arr.forEach(label => {
        const item = document.createElement('div');
        item.textContent = label;

        // Use mousedown instead of click
        item.addEventListener('mousedown', (e) => {
          e.preventDefault(); // Prevent focus loss
          searchInput.value = label;
          const cfg = regions[label];
          map.flyTo({ center: cfg.center, zoom: cfg.zoom, speed: 0.8 });
          closeAllLists();
        });

        autocompleteList.appendChild(item);
      });
    }

    // ‚îÄ‚îÄ FILTER / SORT STATE ‚îÄ‚îÄ
    let currentSortOrder = 'desc';     // 'desc' = Newest first, 'asc' = Oldest first
    let currentFilter    = 'all';      // 'all' | 'vetted' | 'unreviewed'

    // Returns ‚Äújust now‚Äù / ‚ÄúX mins ago‚Äù / ‚ÄúY hrs ago‚Äù / ‚ÄúZ days ago‚Äù
    function relativeTime(dateStr) {
      const then = new Date(dateStr).getTime();
      const diff = Date.now() - then;
      const secs = diff/1000;
      if (secs < 60) return 'just now';
      const mins = secs/60;
      if (mins < 60) return `${Math.round(mins)} mins ago`;
      const hrs = mins/60;
      if (hrs < 24) return `${Math.round(hrs)} hrs ago`;
      const days = hrs/24;
      return `${Math.round(days)} days ago`;
    }

    // Maps confidence_rating ‚Üí your blue scale (fallback to black)
    function getDotColor(r) {
      if (r === null || r === undefined) return '#000';
      if (r < 5)   return '#e0f7fa';
      if (r < 10)  return '#29b6f6';
                   return '#01579b';
    }

    // Add this new function after getDotColor
    function calculateAnimatedSightings() {
      if (!cachedSightings) return;

      const now = Date.now();
      const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);

      // Get sightings from last 7 days
      const recentSightings = cachedSightings.features
        .filter(f => new Date(f.properties.report_date).getTime() >= sevenDaysAgo)
        .sort((a,b) => new Date(b.properties.report_date) - new Date(a.properties.report_date));

      // If less than 10 sightings in 7 days, get the 10 most recent
      let eligibleSightings;
      if (recentSightings.length < 10) {
        eligibleSightings = cachedSightings.features
          .sort((a,b) => new Date(b.properties.report_date) - new Date(a.properties.report_date))
          .slice(0, 10);
        isAnimationRestricted = true;
      } else {
        eligibleSightings = recentSightings;
        isAnimationRestricted = false;
      }

      // Store the IDs of sightings that should be animated
      animatedSightingIds = new Set(
        eligibleSightings.map(f => f.properties.sighting_id)
      );

      console.log(`Animation enabled for ${animatedSightingIds.size} sightings (restricted: ${isAnimationRestricted})`);
    }

    function updateAnimationFilters() {
      if (!animatedSightingIds.size) return;

      const sightingIdsArray = Array.from(animatedSightingIds);
      const rippleLayers = ['pulse-ripple', 'pulse-ripple-2', 'pulse-ripple-3'];

      rippleLayers.forEach(layerId => {
        map.setFilter(layerId, ['all',
          ['!', ['has','point_count']],
          ['in', ['get', 'sighting_id'], ['literal', sightingIdsArray]]
        ]);
      });
    }

    function updateBaseLayerFilters() {
      if (!animatedSightingIds.size) return;

      const sightingIdsArray = Array.from(animatedSightingIds);

      // Update animated base dots filter
      map.setFilter('pulse-base-animated', ['all',
        ['!', ['has','point_count']],
        ['in', ['get', 'sighting_id'], ['literal', sightingIdsArray]]
      ]);

      // Update static base dots filter
      map.setFilter('pulse-base-static', ['all',
        ['!', ['has','point_count']],
        ['!', ['in', ['get', 'sighting_id'], ['literal', sightingIdsArray]]]
      ]);
    }

    // ‚îÄ‚îÄ GLOBAL CACHE FOR YOUR GEOJSON ‚îÄ‚îÄ
    let cachedSightings = null;

    // Add specific ids for animated sighting_ids for ping animations
    let animatedSightingIds = new Set();
    let isAnimationRestricted = false;

    function renderFilterList() {
      const listContainer = document.getElementById('filter-list');
      if (!cachedSightings || !listContainer) return;

      // 1) Copy & filter
      let items = cachedSightings.features.slice();
      if (currentFilter === 'vetted') {
        items = items.filter(f => f.properties.vetted);
      } else if (currentFilter === 'unreviewed') {
        items = items.filter(f => !f.properties.vetted);
      }

      // 2) Sort
      items.sort((a,b) => {
        const da = new Date(a.properties.report_date),
              db = new Date(b.properties.report_date);
        return (currentSortOrder==='desc' ? db-da : da-db);
      });

      // 3) Build HTML
      let html = '<ul style="list-style:none;padding:0;margin:8px 0;">';
      items.forEach(f => {
        const p = f.properties;
        const rel = relativeTime(p.report_date);
        const color = getDotColor(p.confidence_rating);
        const [lng,lat] = f.geometry.coordinates;
        const snippet = p.description.length > 40
          ? p.description.slice(0,40)+'‚Ä¶'
          : p.description;
        html += `
          <li style="margin-bottom:10px;">
            <a href="#" data-coords="${lng},${lat}" style="text-decoration:none;color:inherit;">
              <div style="display:flex;align-items:center;justify-content:space-between;">
                <span style="display:flex;align-items:center;">
                  <span style="width:8px;height:8px;border-radius:50%;background:${color};margin-right:6px;"></span>
                  <strong>${rel}</strong>
                </span>
                <span style="font-size:11px;color:#ccc;">${lat.toFixed(2)},${lng.toFixed(2)}</span>
              </div>
              <div style="font-size:11px;color:#ccc;margin-left:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
                ${snippet}
              </div>
            </a>
          </li>`;
      });
      html += '</ul>';
      listContainer.innerHTML = html;

      // 4) Wire fly‚Äêto
      listContainer.querySelectorAll('a[data-coords]').forEach(a=>{
        a.onclick = e=>{
          e.preventDefault();
          const [lng,lat] = a.dataset.coords.split(',');
          map.flyTo({ center:[+lng,+lat], zoom:10 });
        };
      });
    }

    map.on('load', () => {
          // Initialize spiderifier with error handling
          try {
            spiderifier = new MapboxglSpiderifier(map, {
              animate: true,
              animationSpeed: 200,
              customPin: true,
              circleFootSeparation: 50,
              circleSpiralSwitchover: 10,
              onClick: function(e, marker) {
                e.stopPropagation();
              }
            });
            console.log('‚úÖ Spiderifier initialized successfully');
          } catch (error) {
            console.error('‚ùå Error initializing spiderifier:', error);
          }

          // Function to handle spiderifying clusters
          function spiderifyCluster(clusterId, clusterCoords) {
            console.log('üï∑Ô∏è spiderifyCluster called with:', { clusterId, clusterCoords });

            if (!spiderifier) {
              console.error('‚ùå Spiderifier not initialized!');
              return;
            }

            // Get cluster leaves
            map.getSource('uapSightings').getClusterLeaves(
              clusterId,
              100,
              0,
              (err, features) => {
                if (err) {
                  console.error('‚ùå Error getting cluster leaves:', err);
                  return;
                }

                console.log(`üìç Got ${features.length} features from cluster`);

                if (features.length === 0) {
                  console.warn('‚ö†Ô∏è No features in cluster!');
                  return;
                }

                // Clear any previous spiderfied markers
                spiderifier.unspiderfy();

                // Create markers with your FULL popup functionality
                const markers = features.map((feature, index) => {
                  const el = document.createElement('div');
                  el.className = 'spiderfy-marker';

                  // Enhanced styling for visibility
                  const confidence = feature.properties.confidence_rating;
                  let color = '#000';
                  if (confidence !== null && confidence !== undefined) {
                    if (confidence < 5) color = '#e0f7fa';
                    else if (confidence < 10) color = '#29b6f6';
                    else color = '#01579b';
                  }

                  // Make markers more visible
                  el.style.cssText = `
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background-color: ${color};
                    border: 2px solid rgba(255,255,255,0.9);
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
                  `;

                  const marker = new mapboxgl.Marker({
                    element: el,
                    anchor: 'center',
                  }).setLngLat(feature.geometry.coordinates);

                  // Use your FULL popup code from the hitbox click handler
                  el.addEventListener('click', (e) => {
                    e.stopPropagation();

                    // Close any existing popups first
                    document.querySelectorAll('.mapboxgl-popup').forEach(p => p.remove());

                    // Use the exact same popup code as your hitbox handler
                    const p = feature.properties;

                    let html = `
                      <strong>Reported:</strong> ${p.report_date}<br/>
                      <strong>Event:</strong>    ${p.event_date || 'N/A'}<br/>
                      <strong>Confidence:</strong> ${p.confidence_rating || 'N/A'}<br/>`;

                    // Add embedded video if media_url exists
                    if (p.media_url && p.media_url !== 'null') {
                      const videoUrl = p.media_url;
                      html += `
                      <div style="width: 100%; margin: 10px 0;">
                        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; background: #000; border-radius: 4px;">
                          <video controls style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain;">
                            <source src="${videoUrl}" type="video/mp4">
                            Your browser does not support the video tag.
                          </video>
                        </div>
                      </div>`;
                    }

                    // Add description and source link
                    html += `
                      <p>${p.description.substring(0,200)}‚Ä¶</p>
                      <a href="${p.source}" target="_blank">View at Source</a>`;

                    // Add the collapsible details section
                    html += `
                      <details style="margin-top:8px;">
                        <summary style="cursor:pointer;color:#29b6f6;">
                          Show all attributes
                        </summary>
                        <div style="max-height:300px; overflow-y:auto; margin-top:4px;">
                          <table style="
                            width:100%;
                            table-layout:fixed;
                            border-collapse:collapse;
                            font-size:12px;
                          ">`;

                    for (const [key, value] of Object.entries(p)) {
                      html += `
                        <tr>
                          <th style="
                            text-align:left;
                            padding:2px 4px;
                            border-bottom:1px solid rgba(255,255,255,0.2);
                            white-space:nowrap;
                            width:30%;
                          ">${key}</th>
                          <td style="
                            padding:2px 4px;
                            border-bottom:1px solid rgba(255,255,255,0.2);
                            word-break:break-word;
                            white-space:normal;
                          ">${value}</td>
                        </tr>`;
                    }

                    html += `
                          </table>
                        </div>
                      </details>`;

                    // Check for flight data
                    const sightingIdNum = Number(p.sighting_id);
                    const hasFlights = window.flightDataCache.some(
                      f => Number(f.properties.sighting_id) === sightingIdNum
                    );

                    if (hasFlights) {
                      html += `
                        <button id="show-flight-btn" style="margin-top:8px; display:block;">
                          Flight Data
                        </button>`;
                    }

                    // Create and show the popup
                    const popup = new mapboxgl.Popup({
                      maxWidth: '380px'
                    })
                      .setLngLat(marker.getLngLat()) // Use marker position, not original
                      .setHTML(html)
                      .addTo(map);

                    // Wire up the flight button =)
                    setTimeout(() => {
                      try {
                        const popupEl = document.querySelector('.mapboxgl-popup-content');
                        if (!popupEl) return; // Exit gracefully
                        const showBtn = popupEl.querySelector('#show-flight-btn');
                        if (showBtn) {
                          showBtn.addEventListener('click', () => {
                            // a) remember which sighting
                            window.currentSightingId = p.sighting_id;
                            // b) reveal your controls
                            document.getElementById('flight-controls-container').style.display = 'flex';
                            // c) zoom & lock the map using marker position instead of e.lngLat
                            const markerLngLat = marker.getLngLat();
                            const lng = markerLngLat.lng;
                            const lat = markerLngLat.lat;
                            map.fitBounds([[lng - 0.6, lat - 0.6], [lng + 0.6, lat + 0.6]]);
                            // d) trigger the real loader in flight_widget.js
                            document.getElementById('load-data-btn').click();
                          });
                        }
                      } catch (e) {
                        console.error('Failed to wire flight button:', e);
                      }
                    }, 100); // Small delay to ensure DOM is ready
                  });

                  return marker;
                });

                // Spiderfy with fixed positioning
                try {
                  const result = spiderifier.spiderfy(clusterCoords, markers);
                  console.log('‚úÖ Spiderfy result:', result);
                  map.triggerRepaint();
                } catch (error) {
                  console.error('‚ùå Spiderfy error:', error);
                }
              }
            );
          }

       // 4. Add a test function to manually trigger spiderify on any visible cluster:
      window.testSpiderifyFirst = function() {
        const clusters = map.queryRenderedFeatures({ layers: ['clusters'] });
        console.log('Found clusters:', clusters);

        if (clusters.length > 0) {
          const first = clusters[0];
          console.log('Testing with first cluster:', first);
          spiderifyCluster(
            first.properties.cluster_id,
            first.geometry.coordinates
          );
        } else {
          console.log('No clusters visible. Zoom out to see clusters.');
        }
      };
      // 1) source
      map.addSource('uapSightings', {
        type: 'geojson',
        data: `./uap_sightings.geojson?cb=${Date.now()}`,
        cluster: true,
        clusterMaxZoom: 12,
        clusterRadius: 50
      });

      // ‚îÄ‚îÄ 1a) CACHE THE SIGHTINGS GEOJSON ‚îÄ‚îÄ
      fetch('./uap_sightings.geojson')
        .then(res => res.json())
        .then(data => {
          cachedSightings = data;
          calculateAnimatedSightings();
          updateAnimationFilters();
          updateBaseLayerFilters();
          initializeTimeline(cachedSightings);
        })
        .catch(err => console.error('Failed to load sightings:', err));

      // 2) clusters
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'uapSightings',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': ['step', ['get','point_count'], '#51bbd6', 10, '#f1f075', 30, '#f28cb1'],
          'circle-radius': ['step', ['get','point_count'], 15, 10, 20, 30, 25]
        }
      });

      // 3) cluster counts
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'uapSightings',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium','Arial Unicode MS Bold'],
          'text-size': 12
        }
      });

      // 4a) Animated base dots (recent sightings)
      map.addLayer({
        id: 'pulse-base-animated',
        type: 'circle',
        source: 'uapSightings',
        filter: ['all',
          ['!', ['has','point_count']],
          ['in', ['get', 'sighting_id'], ['literal', []]]
        ],
        paint: {
          'circle-color': ['interpolate',['linear'],['get','confidence_rating'],0,'#e0f7fa',5,'#29b6f6',10,'#01579b'],
          'circle-radius': 4,
          'circle-opacity': 1
        }
      });

      // 4b) Static base dots with subtle pulse (older sightings)
      map.addLayer({
        id: 'pulse-base-static',
        type: 'circle',
        source: 'uapSightings',
        filter: ['all',
          ['!', ['has','point_count']],
          ['!', ['in', ['get', 'sighting_id'], ['literal', []]]]
        ],
        paint: {
          'circle-color': ['interpolate',['linear'],['get','confidence_rating'],0,'#e0f7fa',5,'#29b6f6',10,'#01579b'],
          'circle-radius': 4,
          'circle-opacity': 1,
          'circle-stroke-color': 'rgba(41, 182, 246, 0.4)', // Blue hue like popup
          'circle-stroke-width': 2,
          'circle-stroke-opacity': 0.6
        }
      });

      // 4.1) first ripple
      map.addLayer({
        id: 'pulse-ripple',
        type: 'circle',
        source: 'uapSightings',
        filter: ['all',
          ['!', ['has','point_count']],
          ['in', ['get', 'sighting_id'], ['literal', []]]
        ],
        paint: {
          'circle-color': 'rgba(0,0,0,0)',
          'circle-stroke-color': ['interpolate',['linear'],['get','confidence_rating'],0,'#e0f7fa',5,'#29b6f6',10,'#01579b'],
          'circle-stroke-width': 2,
          'circle-radius': 6,
          'circle-stroke-opacity': 0
        }
      });

      // 4.2) second ripple
      map.addLayer({
        id: 'pulse-ripple-2',
        type: 'circle',
        source: 'uapSightings',
        filter: ['all',
          ['!', ['has','point_count']],
          ['in', ['get', 'sighting_id'], ['literal', []]]
        ],
        paint: {
          'circle-color': 'rgba(0,0,0,0)',
          'circle-stroke-color': ['interpolate',['linear'],['get','confidence_rating'],0,'#e0f7fa',5,'#29b6f6',10,'#01579b'],
          'circle-stroke-width': 2,
          'circle-radius': 6,
          'circle-stroke-opacity': 0
        }
      });

      // 4.2.1) third ripple
      map.addLayer({
        id: 'pulse-ripple-3',
        type: 'circle',
        source: 'uapSightings',
        filter: ['all',
          ['!', ['has','point_count']],
          ['in', ['get', 'sighting_id'], ['literal', []]]
        ],
        paint: {
          'circle-color': 'rgba(0,0,0,0)',
          'circle-stroke-color': ['interpolate',
            ['linear'], ['get','confidence_rating'],
            0,  '#e0f7fa',
            5,  '#29b6f6',
            10, '#01579b'
          ],
          'circle-stroke-width': 2,
          'circle-radius': 6,
          'circle-stroke-opacity': 0
        }
      });

      //4.3) invisible hitbox for easier clicks
      map.addLayer({
        id: 'hitbox',
        type: 'circle',
        source: 'uapSightings',
        filter: ['!', ['has','point_count']],
        paint: {
          // twice the radius of your visual dot:
          'circle-radius': 12,
          // completely invisible
          'circle-opacity': 0
        }
      });

      // replace your existing hitbox-click handler with this:
      window.currentSightingId = null;

      

      map.on('click', 'hitbox', e => {
          // Close any existing popups first
          document.querySelectorAll('.mapboxgl-popup').forEach(p => p.remove());

          // Add bounds checking
          const bounds = map.getBounds();
          const clickPoint = e.lngLat;
          if (!bounds.contains(clickPoint)) return;

          // 1) grab the properties
          const p = e.features[0].properties;

          // 2) build up your HTML (table + details + button)
          let html = `
              <strong>Reported:</strong> ${p.report_date}<br/>
              <strong>Event:</strong>    ${p.event_date || 'N/A'}<br/>
              <strong>Confidence:</strong> ${p.confidence_rating || 'N/A'}<br/>`;

          // 3) Add embedded video if media_url exists - FIXED FORMATTING
          if (p.media_url && p.media_url !== 'null') {
              const videoUrl = p.media_url;

              html += `
              <div style="width: 100%; margin: 10px 0;">
                  <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; background: #000; border-radius: 4px;">
                      <video controls style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain;">
                          <source src="${videoUrl}" type="video/mp4">
                          Your browser does not support the video tag.
                      </video>
                  </div>
              </div>`;
          }

          // 4) Add description and source link
          html += `
              <p>${p.description.substring(0,200)}‚Ä¶</p>
              <a href="${p.source}" target="_blank">View at Source</a>`;

          // 5) Add the collapsible details section
          html += `
              <details style="margin-top:8px;">
                  <summary style="cursor:pointer;color:#29b6f6;">
                      Show all attributes
                  </summary>
                  <div style="max-height:300px; overflow-y:auto; margin-top:4px;">
                      <table style="
                          width:100%;
                          table-layout:fixed;
                          border-collapse:collapse;
                          font-size:12px;
                      ">`;

          for (const [key, value] of Object.entries(p)) {
              html += `
                  <tr>
                      <th style="
                          text-align:left;
                          padding:2px 4px;
                          border-bottom:1px solid rgba(255,255,255,0.2);
                          white-space:nowrap;
                          width:30%;
                      ">${key}</th>
                      <td style="
                          padding:2px 4px;
                          border-bottom:1px solid rgba(255,255,255,0.2);
                          word-break:break-word;
                          white-space:normal;
                      ">${value}</td>
                  </tr>`;
          }

          html += `
                      </table>
                  </div>
              </details>`;

          // 6) determine if this sighting actually has flight data
          const sightingIdNum = Number(p.sighting_id);
          const hasFlights = window.flightDataCache.some(
              f => Number(f.properties.sighting_id) === sightingIdNum
          );

          // 7) append the flight button outside <details>
          if (hasFlights) {
              html += `
                  <button id="show-flight-btn" style="margin-top:8px; display:block;">
                      Flight Data
                  </button>`;
          }

          // 8) show the popup
          new mapboxgl.Popup({
              maxWidth: '380px'  // Slightly wider to accommodate videos
          })
              .setLngLat(e.lngLat)
              .setHTML(html)
              .addTo(map);

          // 9) wire up the Show-Flights button
          const popupEl = document.querySelector('.mapboxgl-popup-content');
          const showBtn  = popupEl.querySelector('#show-flight-btn');
          if (showBtn) {
              showBtn.addEventListener('click', () => {
                  // a) remember which sighting
                  window.currentSightingId = p.sighting_id;
                  // b) reveal your controls
                  document.getElementById('flight-controls-container').style.display = 'flex';
                  // c) zoom & lock the map
                  const [lng, lat] = e.lngLat.toArray();
                  map.fitBounds([[lng - 0.6, lat - 0.6], [lng + 0.6, lat + 0.6]]);
                  // map.touchZoomRotate.disable();
                  // d) trigger the real loader in flight_widget.js
                  document.getElementById('load-data-btn').click();
              });
          }
      });

      // 5. Enhanced cluster click handler with more debugging:
      map.on('click', 'clusters', (e) => {

        console.log('üó∫Ô∏è Cluster clicked!', e);

        // Prevent event bubbling
        e.originalEvent.stopPropagation();

        const features = map.queryRenderedFeatures(e.point, {
          layers: ['clusters']
        });

        console.log('Features at click point:', features);

        if (!features.length) {
          console.log('‚ùå No cluster features found');
          return;
        }

        const clusterId = features[0].properties.cluster_id;
        const clusterCoords = features[0].geometry.coordinates;
        const currentZoom = map.getZoom();

        console.log('üìä Cluster details:', {
          clusterId,
          coordinates: clusterCoords,
          currentZoom,
          pointCount: features[0].properties.point_count
        });

        // Get expansion zoom
        map.getSource('uapSightings').getClusterExpansionZoom(
          clusterId,
          (err, zoom) => {
            if (err) {
              console.error('‚ùå Error getting expansion zoom:', err);
              // Try spiderfy anyway
              spiderifyCluster(clusterId, clusterCoords);
              return;
            }

            console.log(`üîç Current zoom: ${currentZoom}, Expansion zoom: ${zoom}`);

            // Lower the threshold for testing - try spiderfy at zoom 8+
            if (currentZoom >= 5) {
              console.log('üï∑Ô∏è Triggering spiderfy (zoom >= 8)');
              spiderifyCluster(clusterId, clusterCoords);
            } else {
              console.log('üîç Zooming in...');
              map.easeTo({
                center: clusterCoords,
                zoom: zoom,
                duration: 500
              });
            }
          }
        );
      });

      // Add cursor pointer for clusters
      map.on('mouseenter', 'clusters', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'clusters', () => {
        map.getCanvas().style.cursor = '';
      });

      // Unspiderfy when map moves
      map.on('movestart', () => {
        if (spiderifier) spiderifier.unspiderfy();
      });

      // Also unspiderfy when drawer opens/closes
      const hambButton = document.getElementById('hamburger');
      const origDrawerClick = hambButton.onclick;
      hambButton.onclick = function(e) {
        if (spiderifier) spiderifier.unspiderfy();
        // Open drawer - use getElementById since drawer isn't defined yet
        const drawerEl = document.getElementById('drawer');
        drawerEl.classList.add('open');
        document.body.classList.add('drawer-open');
      };

      // your existing close-button logic stays the same:
      document.getElementById('close-btn').addEventListener('click', () => {
        map.dragPan.enable();
        map.touchZoomRotate.enable();
        document.getElementById('flight-controls-container').style.display = 'none';
      });



      // 7) Cursor pointer on hover
      map.on('mouseenter', 'hitbox', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'hitbox', () => map.getCanvas().style.cursor = '');


      // 7.1) controls
      map.addControl(new mapboxgl.NavigationControl());

      // 7.2) legend (with Unreviewed = black)
      document.getElementById('legend').innerHTML = `
        <h4>Confidence Score</h4>
        <!-- 10 ‚Üí deep navy -->
        <span
          style="
            background:#01579b;
            width:12px; height:12px;
            display:inline-block;
            margin-right:6px;
            border-radius:3px;
          "
        ></span> 10<br/>
        <!-- 5 ‚Üí sky blue -->
        <span
          style="
            background:#29b6f6;
            width:12px; height:12px;
            display:inline-block;
            margin-right:6px;
            border-radius:3px;
          "
        ></span> 5<br/>
        <!-- 0 ‚Üí light cyan -->
        <span
          style="
            background:#e0f7fa;
            width:12px; height:12px;
            display:inline-block;
            margin-right:6px;
            border-radius:3px;
          "
        ></span> 0<br/>
        <!-- unreviewed/null -->
        <span
          style="
            background:#000000;
            width:12px; height:12px;
            display:inline-block;
            margin-right:6px;
            border-radius:3px;
          "
        ></span> Unreviewed
      `;

     // 9) smoother ripple via style-transitions (no rAF)
    const CYCLE = 4500;
    const ripples = [
      'pulse-ripple',
      'pulse-ripple-2',
      'pulse-ripple-3'
    ];

    // 1) tell Mapbox GL to interpolate these props over the full cycle
    ripples.forEach(id => {
      map.setPaintProperty(id, 'circle-radius-transition',         { duration: CYCLE });
      map.setPaintProperty(id, 'circle-stroke-opacity-transition', { duration: CYCLE });
    });

    // 2) kick off one full 3-wave ripple
    function triggerRipples() {
      // instantly reset all three
      ripples.forEach(id => {
        map.setPaintProperty(id, 'circle-radius',         6, { duration: 0 });
        map.setPaintProperty(id, 'circle-stroke-opacity', 1, { duration: 0 });
      });
      // wave 1 out
      setTimeout(() => {
        map.setPaintProperty('pulse-ripple', 'circle-radius',         36);
        map.setPaintProperty('pulse-ripple', 'circle-stroke-opacity', 0);
      },  50);
      // wave 2 out
      setTimeout(() => {
        map.setPaintProperty('pulse-ripple-2', 'circle-radius',         36);
        map.setPaintProperty('pulse-ripple-2', 'circle-stroke-opacity', 0);
      }, 1500);
      // wave 3 out
      setTimeout(() => {
        map.setPaintProperty('pulse-ripple-3', 'circle-radius',         36);
        map.setPaintProperty('pulse-ripple-3', 'circle-stroke-opacity', 0);
      }, 3000);
    }

    // Add subtle pulse animation for static dots
    function initStaticPulse() {
      // Set up transition properties for smooth pulsing
      map.setPaintProperty('pulse-base-static', 'circle-stroke-opacity-transition', { duration: 2000 });
      map.setPaintProperty('pulse-base-static', 'circle-stroke-width-transition', { duration: 2000 });
      map.setPaintProperty('pulse-base-static', 'circle-radius-transition', { duration: 2000 });

      // Start the pulsing animation
      function pulseStatic() {
        // Pulse out: dimmer hue, wider stroke, larger dot
        map.setPaintProperty('pulse-base-static', 'circle-stroke-opacity', 0.2);
        map.setPaintProperty('pulse-base-static', 'circle-stroke-width', 3);
        map.setPaintProperty('pulse-base-static', 'circle-radius', 6);

        // Pulse back in after 1 second: brighter hue, normal stroke, normal size
        setTimeout(() => {
          map.setPaintProperty('pulse-base-static', 'circle-stroke-opacity', 0.6);
          map.setPaintProperty('pulse-base-static', 'circle-stroke-width', 2);
          map.setPaintProperty('pulse-base-static', 'circle-radius', 4);
        }, 1000);
      }

      // Start immediately and repeat every 3 seconds
      pulseStatic();
      setInterval(pulseStatic, 3000);
    }

    // 3) start immediately, then loop
    triggerRipples();
    setInterval(triggerRipples, CYCLE);

    // Initialize static pulse for older sightings
    initStaticPulse();

      // Grab references
      const drawer = document.getElementById('drawer');
      const panels = {
        recent: null,       // we‚Äôll build recent on each click
        timeline: null,     // handled specially below
        confidence: null
      };



      const closeBtn = document.getElementById('close-drawer');

      closeBtn.addEventListener('click', () => {
        // close drawer + unmark body
        drawer.classList.remove('open');
        document.body.classList.remove('drawer-open');
        if (spiderifier) spiderifier.unspiderfy();
      });

      // 2) Drawer nav: stacked buttons
      drawer.querySelectorAll('nav button').forEach(btn => {
        btn.onclick = () => {
          const panel = btn.dataset.panel;
          const container = document.getElementById('drawer-content');

          // Timeline panel ‚Üí checkbox
          if (panel === 'timeline') {
            container.innerHTML = `
              <label style="display:flex;align-items:center;">
                <input type="checkbox" id="toggle-timeline" style="margin-right:8px;">
                Show timeline bar
              </label>
              <p style="font-size:12px;margin-top:8px;color:#ccc;">
                Use this to show or hide the bottom-center slider.
              </p>
            `;
            document.getElementById('toggle-timeline').onchange = e => {
              document.getElementById('slider-container').style.display =
                e.target.checked ? 'block' : 'none';
            };
            return;
          }

          if (panel === 'filter') {
            container.innerHTML = `
              <h4>Filter &amp; Sort</h4>
              <div style="margin:8px 0;">
                <label>
                  Sort:
                  <select id="sort-order" style="margin-left:4px;">
                    <option value="desc">Newest First</option>
                    <option value="asc">Oldest First</option>
                  </select>
                </label>
              </div>
              <div style="margin-bottom:8px;">
                <label><input type="radio" name="filter" value="all" checked> All</label>
                <label style="margin-left:12px;"><input type="radio" name="filter" value="vetted"> Vetted</label>
                <label style="margin-left:12px;"><input type="radio" name="filter" value="unreviewed"> Unreviewed</label>
              </div>
              <div id="filter-list" style="overflow-y:auto;max-height:calc(100% - 100px);"></div>
            `;

            // initialize controls
            const sortEl = document.getElementById('sort-order');
            sortEl.value = currentSortOrder;
            sortEl.onchange = e => {
              currentSortOrder = e.target.value;
              renderFilterList();
            };

            container.querySelectorAll('input[name="filter"]').forEach(radio => {
              radio.checked = (radio.value === currentFilter);
              radio.onchange = e => {
                currentFilter = e.target.value;
                renderFilterList();
              };
            });

            // initial render
            renderFilterList();
            return;
          }

          // Replace the existing 'recent' panel case with this:
          if (panel === 'recent') {
            container.innerHTML = '';
            if (!cachedSightings) {
              container.innerHTML = '<p>Loading‚Ä¶</p>';
              return;
            }

            // Get sightings from the last 7 days, extend to 50 if needed
            const now = Date.now();
            const weekAgo = now - (7 * 24 * 60 * 60 * 1000);

            let recentSightings = cachedSightings.features
              .filter(f => new Date(f.properties.report_date).getTime() >= weekAgo)
              .sort((a,b) =>
                new Date(b.properties.report_date) - new Date(a.properties.report_date)
              );

            // If less than 50 sightings in the past week, get the most recent 50
            if (recentSightings.length < 50) {
              recentSightings = cachedSightings.features
                .sort((a,b) =>
                  new Date(b.properties.report_date) - new Date(a.properties.report_date)
                )
                .slice(0, 50);
            }

            // Build HTML without the ticker-container wrapper
            let html = `
              <h4 style="margin: 0 0 12px 0; position: sticky; top: 0; padding: 8px 0;">Recent Sightings</h4>
              <ul class="recent-list" style="
                list-style: none;
                margin: 0;
                padding: 0;
              ">`;

            if (recentSightings.length === 0) {
              html += '<li style="color: #999; padding: 10px;">No recent sightings</li>';
            } else {
              recentSightings.forEach(f => {
                const props = f.properties;
                const rel = relativeTime(props.report_date);
                const [lng,lat] = f.geometry.coordinates;
                const loc = `${lat.toFixed(2)}, ${lng.toFixed(2)}`;
                const color = getDotColor(props.confidence_rating);
                const snippet = props.description.length > 50
                  ? props.description.slice(0,50) + '‚Ä¶'
                  : props.description;

                html += `
                  <li class="recent-item" style="margin-bottom: 12px;">
                    <a href="#" data-coords="${lng},${lat}" style="text-decoration:none;color:inherit;display:block;">
                      <div class="line" style="display:flex;justify-content:space-between;align-items:center;">
                        <span style="display:flex;align-items:center;">
                          <span class="dot" style="width:8px;height:8px;border-radius:50%;background:${color};margin-right:6px;"></span>
                          <strong>${rel}</strong>
                        </span>
                        <span style="font-size:11px;color:#ccc;">${loc}</span>
                      </div>
                      <div class="snippet" style="margin-left:14px;font-size:11px;color:#ccc;margin-top:2px;">
                        ${snippet}
                      </div>
                    </a>
                  </li>`;
              });
            }

            html += '</ul>';
            container.innerHTML = html;

            // Attach fly-to handlers
            container.querySelectorAll('a[data-coords]').forEach(link => {
              link.addEventListener('click', e => {
                e.preventDefault();
                const [lng,lat] = link.dataset.coords.split(',');
                map.flyTo({ center: [parseFloat(lng), parseFloat(lat)], zoom: 10 });
                document.getElementById('close-drawer').click();
              });
            });

            return;
          }

          if (panel === 'stats') {
            // make sure our cached geojson is loaded
            if (!cachedSightings) {
              container.innerHTML = '<p>Loading stats‚Ä¶</p>';
              return;
            }

            const now   = Date.now();
            const msDay = 24 * 60 * 60 * 1000;
            const since24h = now - msDay;
            const sinceWeek = now - 7 * msDay;

            const features = cachedSightings.features;

            // 1) Total in last 24h
            const count24h = features.filter(f =>
              new Date(f.properties.report_date).getTime() >= since24h
            ).length;

            // 2) High-confidence (‚â• 8) in last week
            const countHigh = features.filter(f =>
              f.properties.confidence_rating >= 8 &&
              new Date(f.properties.report_date).getTime() >= sinceWeek
            ).length;

            // 3) Build a 7-day sparkline
            // initialize a map day‚Üícount
            const daily = {};
            for (let i = 6; i >= 0; i--) {
              const d = new Date();
              d.setDate(d.getDate() - i);
              const key = d.toISOString().split('T')[0];
              daily[key] = 0;
            }
            // tally
            features.forEach(f => {
              const day = f.properties.report_date.split('T')[0];
              if (daily[day] !== undefined) daily[day]++;
            });
            const counts = Object.values(daily);
            const maxCount = Math.max(...counts, 1);

            // render bars
            let sparkHtml = '<div style="display:flex;align-items:flex-end;gap:4px;height:40px;margin-top:6px;">';
            counts.forEach(c => {
              const h = Math.round((c / maxCount) * 100);
              sparkHtml += `<div style="
                  flex:1;
                  background: rgba(41, 182, 246, 0.6);
                  height:${h}%;
                  border-radius:2px;
                "></div>`;
            });
            sparkHtml += '</div>';

            // 4) Inject into drawer
            container.innerHTML = `
              <h4>Stats (last 7 days)</h4>
              <p><strong>${count24h}</strong> sightings in last 24 hrs</p>
              <p><strong>${countHigh}</strong> high-confidence (‚â• 8) in last week</p>
              ${sparkHtml}
            `;
            return;
          }

          if (panel === 'confidence') {
            container.textContent = 'Coming soon‚Ä¶';
          }
        };
      });

      // ‚îÄ‚îÄ B) SLIDER INITIALIZATION FUNCTION ‚îÄ‚îÄ
      function initializeTimeline(allData) {
        const dates = Array.from(
          new Set(allData.features.map(f => f.properties.report_date))
        ).sort();
        const slider = document.getElementById('time-slider');
        const label  = document.getElementById('time-label');
        slider.min   = 0;
        slider.max   = dates.length - 1;
        slider.value = dates.length - 1;
        function update(i) {
          const cutoff = dates[i];
          label.innerText = `Showing sightings up to ${new Date(cutoff).toLocaleString()}`;
          const filtered = allData.features.filter(f => f.properties.report_date <= cutoff);
          map.getSource('uapSightings').setData({ type:'FeatureCollection', features:filtered });
        }
        slider.oninput = e => update(+e.target.value);
        update(dates.length - 1);
      }

    });

    // ‚îÄ‚îÄ OPEN MODAL FUNCTION ‚îÄ‚îÄ
    const infoBtn   = document.getElementById('info');
    const aboutModal = document.getElementById('about-modal');
    const aboutClose = document.getElementById('about-close');

    // open modal
    infoBtn.addEventListener('click', () => {
      aboutModal.classList.remove('hidden');
    });

    // close modal
    aboutClose.addEventListener('click', () => {
      aboutModal.classList.add('hidden');
});

  </script>



  <!-- 1) Load the widget code -->
  <script src="flight_widget.js"></script>

  <!-- 2) Hook it into your Mapbox map -->
  <script>
    // once the map itself has loaded, bootstrap the flight widget
    map.on('load', () => {
      initFlightWidget(map);
    });
  </script>
</body>